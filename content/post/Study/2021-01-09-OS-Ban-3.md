---
title: 운영체제와 정보기술의 원리 정리
date: 2021-01-09
tag: [Study]
---

`참고` 이 글은 반효경 교수님의 "운영체제와 정보기술의 원리"를 바탕으로 공부한 내용을 정리한 것입니다.

<br><br>

## 3장 컴퓨터 시스템의 동작 원리

### 1. 컴퓨터 시스템의 구조

- 컴퓨터 시스템은 컴퓨터 내부장치(CPU, 메모리)와 외부장치(디스크, 키보드, 마우스, 모니터, 네트워크 장치 등)로 구성됩니다.  
- 운영체제는 각종 자원 관리를 위해 항상 메모리에 올라가있어야 하는데 모든 코드가 메모리에 올라가게되면 메모리가 낭비되므로 핵심적인 부분만 메모리에 올리게됩니다. 이를 `커널`이라고 부릅니다.

### 2. CPU 연산과 I/O 연산

- 각 입출력 장치들의 I/O 연산은 `입출력 컨트롤러`가 담당하고, 컴퓨터 내에 수행되는 연산은 메인 CPU가 담당합니다.
- 그리고 각 입출력 장치들의 컨트롤러는 장치로부터 오고나가는 데이터를 임시로 저장하기위해 `로컬 버퍼`라는 작은 메모리를 가지게 됩니다.
- 장치로부터 로컬 버퍼로 데이터를 읽어오는 역할은 컨트롤러가 담당하는데, 이 역할이 끝나게되면 인터럽트를 통해 CPU에게 작업 완료를 알리게됩니다.

### 3. 인터럽트의 일반적 기능

- 운영체제 커널 안에는 각 인터럽트에 대한 처리 루틴이 미리 프로그래밍 되어 있어서 인터럽트가 발생하면 이를 사용합니다.
- 인터럽트에는 `하드웨어 인터럽트`와 `소프트웨어 인터럽트`가 있습니다. 하드웨어 인터럽트는 통상적으로 우리가 일컷는 인터럽트를 말하며, 소프트웨어 인터럽트는 예외상황(Exception)이나 시스템 콜(System call)로 인해 발생하는 인터럽트를 의미합니다. 여기서 예외상황은 0으로 나누는 것, 자신의 메모리 바깥 영역에 침범하는 등의 예외적인 상황을 말합니다.

### 4. 인터럽트 핸들링

- 인터럽트가 발생하면 실행중이던 프로그램의 상태를 PCB에 저장한 뒤, 인터럽트 처리 루틴에 따라 인터럽트를 처리하게 됩니다. 그리고 인터럽트 처리가 끝나게되면 저장해두었던 상태를 프로그램의 PCB로부터 복원해서 인터럽트 당하기 직전의 위치부터 실행을 재개합니다.

### 5. 입출력 구조

- 입출력 방식에는 동기식 입출력과 비동기식 입출력이 존재합니다.
- `동기식 입출력`은 어떤 프로그램이 입출력 요청을 했을 때, 입출력 작업이 완료된 뒤에야 후속 작업을 수행할 수 있는 것을 말합니다. 이때문에 동기식 입출력에서는 CPU가 입출력이 끝날때까지 기다리기 때문에 CPU 자원을 낭비하게 됩니다. 따라서 일반적으로는 프로그램이 입출력을 수행하는 경우 CPU를 다른 프로그램에게 넘겨서 CPU를 계속 사용하도록 하고, 입출력 과정이 완료될 때까지 해당 프로그램을 Block 상태로 만들어서 CPU를 할당하지 않습니다.  
  (참고로, 입출력 과정이 완료되면 위에서 설명했듯이 입출력 컨트롤러가 CPU에게 인터럽트를 보내게되며 Block 상태가 해제됩니다.)
- 이런 동기식 입출력은 입출력에 걸린 프로그램으로부터 CPU를 빼앗아 다른 프로그램에게 넘기기 때문에 연산 과정의 순서가 꼬일 위험이 있습니다. 이러한 문제점, 즉 동기화 문제를 해결하기 위해 장치별로 큐(Queue)를 두고 요청한 순서대로 처리합니다.
- `비동기식 입출력`은 어떤 프로그램이 입출력 요청을 했을 때, 다시 그 프로그램에게 CPU를 부여합니다. 이렇게 함으로써 입출력 결과로 나올 데이터를 사용하지 않는 작업을 먼저 수행합니다.
- 일반적으로는 동기식 입출력을 사용한다고 합니다.

### 6. DMA(Direct Memory Access)

- 원칙적으로 메모리는 CPU만이 접근할 수 있는 장치입니다. 따라서 CPU가 아닌 장치가 메모리에 접근하기 위해서는 CPU에게 부탁하는 방식으로만 가능합니다.
- 하지만 이렇게 하다보니 입출력 장치가 메모리 접근을 원할때마다 CPU에게 부탁을 하게되고 CPU는 자기 할 일을 못하게됩니다.
- 이러한 문제를 해결하기 위해 CPU 이외에 메모리에 접근할 수 있는 장치를 하나 더 두었는데 이것이 바로 `DMA`입니다. DMA는 일종의 컨트롤러로, 로컬버퍼에서 메모리로 읽어오는 작업을 DMA가 CPU 대신 수행해서 CPU가 이로인해 방해받지 않도록 합니다. DMA는 이렇게 로컬버퍼의 데이터를 메모리로 읽어온 뒤 CPU에게 완료되었다는 인터럽트를 발생시키게됩니다.

### 7. 저장장치의 구조

- 컴퓨터 시스템을 구성하는 저장장치는 주기억장치와 보조기억장치로 나뉩니다.
- 보조기억 장치의 용도는 파일을 저장하기 위한 파일 시스템용과 메모리의 연장공간인 스왑 영역이 있습니다.
- 현대의 컴퓨터는 프로그램 수행에 당장 필요한 부분만 메모리에 올려놓고 그렇지 않은 부분을 `스왑 영역`에 내려놓게 됩니다.

### 8. 저장장치의 계층 구조

- 레지스터 - 캐시메모리 - 메인메모리 - 마그네틱디스크 - 광디스크 - 마그네틱테이프

### 9. 하드웨어 보안

- 운영체제는 하드웨어적인 보안을 유지하기 위해서 커널모드와 사용자모드를 나눕니다. CPU 내부에 모드비트(mode bit)라는 걸 두고 0일 때는 커널모드, 1일때는 사용자모드로서 명령을 수행할 수 있게합니다.

### 10. 메모리 보안

- C언어 포인터 등 메모리 주소 참조 연산을 잘못해서 다른 프로그램의 메모리 영역이나 커널 영역을 참조하게 될 수 있습니다. 이는 보안적인 문제인데, 이는 2개의 레지스터를 사용해서 프로그램이 접근하려는 메모리 부분이 합법적인지 체크함으로써 해결할 수 있습니다.
- 2개의 레지스터는 기준 레지스터와 한계 레지스터입니다. `기준 레지스터`에는 프로그램이 접근할 수 있는 가장 작은 주소가, `한계 레지스터`에는 프로그램이 접근할 수 있는 범위를 보관하고 있어서, "기준 레지스터에 있는 주소 ~ 기준 레지스터에 범위(한계 레지스터 값)을 더한 만큼"까지의 범위만을 프로그램이 접근할 수 있게됩니다.

### 11. CPU 보호

- CPU가 하나의 프로그램에 의해 독점되는 것을 막기 위해 OS에서는 타이머(timer)라는 하드웨어를 사용합니다. 타이머는 정해진 시간이 지나면 인터럽트를 발생시켜서 운영체제가 CPU의 제어권을 획득 할 수 있도록 합니다.
- 타이머는 매 클럭 틱(clock tick)마다 1씩 감소하고 0이되는 순간에 폭발합니다.

### 12. 시스템 콜을 이용한 입출력 수행

- 입출력은 특권명령에 해당하므로 사용자 프로그램이 직접 수행할 수 없습니다. 따라서 운영체제에게 시스템 콜을 요청하여 입출력을 수행하게 됩니다.
- 즉, `시스템 콜`은 입출력 명령을 사용하기 위한 인터페이스라고 볼 수 있습니다.

<br>
---
<br>

## 4장 프로그램의 구조와 실행

### 1. 프로그램의 구조와 인터럽트

- 프로그램이 CPU에서 명령을 수행하려면 해당 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야합니다. 이때 프로그램의 주소 영역은 코드, 데이터, 스택 영역으로 구분됩니다.
- `코드(code) 영역`은 우리가 작성한 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 저장되는 부분이고,
- `데이터(data) 영역`은 전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분이며,
- `스택(stack) 영역`은 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데 사용되는 공간입니다.

### 2. 컴퓨터 시스템의 작동 개요

- `프로그램 카운터(Program Counter: PC)`란, CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 의미합니다. CPU는 매번 PC가 가리키는 메모리 위치의 명령을 처리합니다.

### 3. 프로그램의 실행

- 각각의 프로세스는 자신만의 물리적인 메모리 주소 공간을 갖습니다. 그리고 이 주소 공간 안에서 코드 영역, 데이터 영역, 스택 영역을 가지는데, 이처럼 프로그램마다 독자적으로 존재하는 주소공간을 `가상 메모리`라고 합니다.
- 운영체제 커널 역시 코드 영역, 데이터 영역, 스택 영역을 가집니다.
- 커널의 코드 영역은 CPU와 메모리 자원관리 같은 역할을 하는 부분이 주를 이루며,
- 데이터 영역에는 각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 유지하기 위한 자료구조인 PCB를 두고 있습니다.
- 커널의 스택 영역에는 현재 수행 중인 프로세스마다 별도의 수택을 두어 관리하는데, 프로세스가 시스템 콜을 호출하였을 때 시스템 콜에서 호출하는 함수들의 주소를 보관하여 호출 이후 다시 복귀하기 위함입니다.

### 4. 사용자 프로그램이 사용하는 함수

- 프로그램이 사용하는 함수는 크게 3가지로, 사용자 정의함수, 라이브러리 함수, 커널 함수가 있습니다.
- 사용자 정의 함수는 개발자가 직접 작성한 함수를, 라이브러리 함수는 다른 개발자가 작성해 놓은 함수를 사용하는 것을 의미하며, 두 가지 모두 해당 프로그램의 코드 영역에서 관리됩니다.
- 하지만 커널 함수의 경우에는 운영체제 커널의 주소 공간에 코드가 정의됩니다.

### 5. 인터럽트

- CPU는 프로그램 카운터가 기리키는 곳에 있는 명령을 수행하는 일밖에 하지 않기 때문에, 현재 수행 중인 프로세스로부터 CPU를 회수하여 다른 프로세스에세 CPU를 할당하기 위해서는 인터럽트 매커니즘이 필요합니다.

### 6. 시스템 콜

- 프로그램이 CPU를 할당 받고 명령을 수행하다가 중간에 CPU를 빼앗기는 경우는 두 가지 경우입니다. 첫번째는 타이머 인터럽트에 의해 빼앗기는 경우이고, 두번째는 시스템 콜로 인해 CPU를 빼앗기는 경우입니다. 시스템 콜을 통한 작업은 시간이 오래걸리므로(예를들면 입출력) 해당 프로세스를 Block 상태로 만들어 놓은 뒤 다른 프로세스에게 CPU를 넘겨주어 CPU가 놀지 않도록 합니다.

### 7. 프로세스의 두 가지 실행 상태

- 프로세스의 실행 상태는 `사용자 모드에서의 실행 상태`와 `커널 모드에서의 실행 상태`로 나뉩니다. 프로세스가 일반적으로 실행중일 때는 사용자 모드에서 실행되지만 시스템 콜을 사용하게되면 커널 모드로 스위칭되어 커널 모드에서의 실행 상태가 됩니다. 이때, CPU는 운영체제에게 빼앗기긴하지만 결국 해당 시스템 콜로 인한 작업 역시 해당 프로세스를 위한 작업이므로 실행 상태로 간주합니다.

<br>
---
<br>

## 5장 프로세스 관리

### 1. 프로세스의 개념

- 프로세스란 실행 중인 프로그램을 뜻합니다.
- 여러개의 프로세스가 수행되는 시분할 시스템 환경에서는 프로세스들이 인터럽트에 의해서 CPU를 사용하다가 뺏기다가 사용하다가 뺏기다가를 반복하게 됩니다. 이 때, 다시 자신의 수행하던 시점부터 프로세스를 이어나가기 위해서는 해당 프로세스에 대한 정보가 필요한데, 이를 `프로세스 문맥`이라고 합니다.
- 프로세스 문맥에는 해당 프로세스의 주소 공간, 레지스터에 어떤 값을 가지고 있었는지, 시스템 콜 등을 통해 커널에서 수행한 일의 상태, 해당 프로세스에 대해 커널이 관리하는 각종 정보들 등이 포함되어 있습니다.

### 2. 프로세스의 상태

- 프로세스의 상태는 실행(running), 준비(ready), 봉쇄(blocked, wait, sleep)의 세 가지 상태로 구분할 수 있습니다.
- `실행 상태(running)`는 프로세스가 CPU를 보유하고 기계어 명령을 실행하고 있는 상태를 의미합니다.
- `준비 상태(ready)`는 프로세스가 CPU만 할당받기만 하면 당장 명령을 실행할 수 있는 상태를 의미합니다.
- `봉쇄 상태(blocked, wait, sleep)`는 CPU를 할당받더라도 당장 명령을 실행할 수 없는 상태를 말합니다. 예시로는 입출력 처리중인 프로세스가 있습니다.
- 이 외에도 프로세스가 생성중이라면 `시작 상태(new)`, 프로세스가 종료 중이라면 `종료 상태(terminated)`라는 용어도 있습니다.

### 3. 프로세스 제어블록 (PCB)

- 프로세스 제어블록(PCB)이란 운영체제가 시스템 내의 프로세스들을 관리하기 위해, 각각의 프로세스마다 해당 프로세스의 정보를 저장하는 커널 내의 자료구조를 말합니다.
- PCB는 다음과 같은 요소들로 구성되어있습니다.
  - 프로세스의 상태
  - 프로그램 카운터 값
  - CPU 레지스터 값
  - CPU 스케줄링 정보
  - 메모리 관리 정보
  - 자원 사용 정보
  - 입출력 상태 정보

### 4. 문맥교환

- `문맥 교환`이란 실행시킬 프로세스를 변경하기 위해 원래 수행 중이던 프로세스의 문맥을 저장하고, 새로운 프로세스로 CPU를 이양하는 과정을 말합니다.

### 5. 프로세스를 스케줄링하기 위한 큐

- 커널의 데이터 영역에는 다양한 큐를 두어 프로세스의 상태를 관리합니다. 대표적인 큐들은 다음과 같습니다.
- 어떤 프로세스에게 CPU를 할당할 것인지를 처리하기 위해 준비 큐(ready queue)를 사용합니다.
- 특정 자원을 기다리는 프로세스들을 처리하기 위해 장치 큐(device queue)를 사용합니다. 예를 들면 디스크 입출력 큐가 있습니다.
- 공유 데이터에 접근하고자 하는 프로세스들에 대해서도 큐를 사용하게 됩니다.

### 6. 스케줄러

- 스케줄러랑 어떤 프로세스에게 자원을 할당할지를 결정하는 운영체제 커널의 코드 영역을 말합니다. 그리고 스케줄러에는 장기 스케줄러와 단기 스케줄러가 있습니다.
- `장기 스케줄러`는 어떤 프로세스를 준비 큐에 넣을지를 결정하는 역할을 합니다. 준비 큐에 프로세스가 있다는 것은 CPU만 할당받으면 실행할 수 있다는 의미이므로, 준비 큐에 넣기전에 메모리 공간을 확보하는 등의 과정이 선행돼야 합니다.  
  (장기 스케줄러는 현대의 시분할 시스템용 운영체제에서는 사용하지 않는다고 합니다. 바로바로 준비 큐에 넣어준다네요)
- `중기 스케줄러`는 너무 많은 프로세스에게 메모리를 할당해주어서 시스템 성능이 저하되는 경우, 이를 해결하기 위해 메모리에 적재된 프로세스들 중 어떤 프로세스를 스왑아웃 할지 결정하는 역할을 합니다.  
  (1순위는 봉쇄 상태에 있는 프로세스라고 합니다)
- `단기 스케줄러`는 CPU 스케줄러라고도 하며, 준비 상태의 프로세스들 중 어떤 프로세스를 다음에 실행할 지를 결정합니다.

### 7. 프로세스의 생성

<br>

### 8. 프로세스 간의 협력

- `IPC(Inter-Process Communication)`란 하나의 컴퓨터 안에서 실행 중인 서로 다른 프로세스간의 통신과 동기화를 이루기 위한 매커니즘입니다. IPC의 대표적인 방법으로는 메시지 전달 방식과 공유메모리 방식이 있습니다.
- `메시지 전달 방식`은 프로세스 간에 공유 데이터를 사용하지 않고 커널을 경유해 메시지를 주고 받는 방법입니다. 커널을 경유하는 이유는, 다른 프로세스가 원치 않는 메시지를 전달해 악영향을 미치는 상황을 피하기 위해서 메세지를 주고 받는 연산을 특권명령으로 규정해두었기 때문입니다.
- `공유 메모리 방식`은 운영체제가 지원하는 공유 메모리 시스템 콜을 사용하여 각자의 주소 공간에 공통적으로 포함되는 영역을 읽고 쓸 수 있게 할 수 있습니다. 이 방식을 사용할 때는 공유 메모리 내부에 있는 데이터에 대해서는 커널이 책임지지 않기 때문에 직접 동기화 문제를 해결해야 합니다.

<br>
---
<br>

## 6장 CPU 스케줄링

### 1. CPU 스케줄러

- CPU 스케줄러는 준비 상태에 있는 프로세스들 중 어떤 프로세스에게 CPU를 할당할지 결정하는 운영체제의 코드를 말합니다.
- CPU 스케줄링 방식에는 선점형과 비 선점형 방식이 있습니다.

### 2. 디스패처

- `디스패처(dispatcher)`란, CPU를 이양받기로 선택된 프로세스가 작업을 수행할 수 있도록 환경설정을 하는 운영체제의 코드를 말합니다.
- 디스패처는 현재 수행중이던 프로세스의 문맥을 해당 프로세스의 PCB에 저장하고, 새롭게 선택된 프로세스의 문맥을 PCB로부터 복원한 후 그 프로세스에게 CPU를 이양하는 과정을 수행합니다.

### 3. 스케줄링의 성능 평가

- 스케줄링 기법의 성능을 평가하기 위한 지표는 시스템 관점의 지표와 사용자 관점의 지표로 나뉩니다.
- 시스템 관점의 지표로는 CPU 이용율과 처리량이 있으며,
- 사용자 관점의 지표로는 소요시간, 대기시간, 응답시간이 있습니다.

### 4. 스케줄리 알고리즘

- `FCFS(First-Come First-Service)` 스케줄링은 프로세스가 준비 큐에 도착한 시간 순서대로 CPU를 할당하는 방식을 말합니다. 콘보이 효과가 발생할 수 있다는 단점이 있습니다.
- `SJF(Shortest-Job First)` 스케줄링은 CPU 버스트가 가장 짧은 프로세스에게 제일 먼저 CPU를 할당하는 방식을 말합니다. 이 방식은 평균 대기시간을 가장 짧게 할 수 있는 최적 알고리즘입니다. SJF에는 선점형 방식과 비선점형 방식이 있는데, 선점형 구현 방식을 SRTF(Shortest Remaining Time First)라고 합니다. 기아 현상이 발생할 수 있다는 단점이 있습니다.
- `우선순위(priority)` 스케줄링은 준비 큐에서 기다리는 프로세스들 중 우선순위가 가장 높은 프로세스에게 제일 먼저 CPU를 할당하는 방식을 말합니다.  
  (HRRN이 여기에 해당되는 것 같네요)
- `라운드 로빈(Round Robin)` 스케줄링은 각 프로세스가 CPU를 연속적으로 사용할 수 있는 시간을 정해놓고(time quantum), 이 시간이 경과하면 다음 프로세스에게 CPU를 할당하는 비선점 스케줄링 방식입니다. 라운드 로빈 스케줄링에서는 time quantum을 잘 조절해주는 것이 중요합니다.
- `멀티레벨 큐(Multilevel Queue)`는 일반적으로 성격이 다른 프로세스들을 별도로 관리하고, 프로세스의 성격에 맞는 스케줄링을 적용하기 위해 준비큐를 별도로 두는 방식입니다. 예를들어 빠른 응답을 필요로하는 대화영 작업과 그렇지 않은 작업을 별도의 큐로 관리한다면, 대화형 작업이 기다리는 경우에는 해당 큐에 우선적으로 CPU를 할당하며, 아닐때는 다른 큐에 우선적으로 CPU를 할당합니다.
- `멀티레벨 피드백 큐(Multilevel Feedback Queue)`는 여러 레벨의 큐를 두고, 프로세스가 큐를 이동하는 방식입니다. 예를들어 aging 기법에 의해 우선순위가 높아진 프로세스는 지금보다 우선순위가 더 높은 큐로 이동하는 방식입니다.

<br>
---
<br>

## 7장 메모리 관리

### 1. 주소 바인딩

- 프로세스는 자신만의 독자적인 주소공간인 논리적 주소, 혹은 가상 주소를 가지고 있고, 물리적으로 메모리 상 어디에 위치하는지를 의미하는 물리 주소 역시 가지고 있습니다. 이때, 논리적 주소를 통해 메모리를 참조하게 되면, 해당 논리적 주소가 물리적 주소의 어느 위치에 매핑되어 있는지를 확인해야 하는데 이렇게 프로세스의 논리적인 주소를 물리적 메모리 주소로 연결시켜주는 작업을 `주소 바인딩`이라고 합니다.
- `MMU(Memory Management Unit) 기법`은 CPU가 특정 프로세스의 논리적 주소를 참조하려고 할 때, 그 논리적 주소값에 기준 레지스터의 값을 더해 물리 주소값을 얻어냅니다. 이때 기준 레지스터는 재배치 레지스터라고 하기도 하며, 3장에서 살펴보았듯이 프로세스의 물리적 메모리 시작주소를 가집니다.

### 2. 메모리 관리와 관련된 용어

- `동적로딩`은 프로세스가 시작될 때 그 프로세스의 주소 공간 전체를 메모리에 모두 올려놓는 것이 아니라 해당 부분이 불릴 때만 올려놓기 때문에 보다 효율적으로 메모리를 사용할 수 있습니다. 예를 들어 에러처리와 같은 코드들을 실제로 많이 사용되지 않으므로 내려놓고 있다가 필요할 때만 올리게됩니다.
- `동적연결`은 라이브러리 함수가 호출되는 시점에 라이브러리에 대한 연결이 이루어집니다. 동적연결은 다수의 프로그램이 공통으로 사용하는 라이브러리를 메모리에 한 번만 적재하므로 메모리 사용의 효율성을 높일 수 있습니다.
- `중첩(overlay)`란 프로세스의 주소 공간을 분할해 실제 필요한 부분만을 메모리에 적재하는 기법입니다. 동적로딩과는 개념적으로 유사하나 사용하는 이유가 다릅니다. 중첩은 초창기 컴퓨터 시스템에서 물리적 메모리가 부족한 상황으로 인해 하나의 프로세스조차도 메모리에 올릴 수 없을 때 사용하던 기법인 반면, 동적로딩은 다중프로그래밍 환경에서 메모리 이용률을 높이기 위해서 사용하는 기법입니다.
- `스와핑(swapping)`이란 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 스왑 영역(= 백킹스토어: backing store)에 일시적으로 내려놓는 것을 말합니다. 스와핑은 swap in과 swap out으로 나뉘며, 중기 스케줄러에 의해 발생합니다.

### 3. 물리적 메모리의 할당 방식

- 연속할당 방식은 물리적 메모리를 다수의 분할로 나누어 하나의 분할에 하나의 프로세스가 적재되도록 하는 방식이며, 불연속할당 방식은 하나의 프로세스를 물리적 메모리의 여러 영역에 반순해 적재하는 방식입니다.
- `연속할당 방식 - 고정분할, 가변분할`
  - 고정분할은 물리적 메모리를 주어진 개수만큼의 영구적인 분할로 미리 나누어두고 각 분할에 하나의 프로세스를 적재해 실행하는 방식입니다. 내부조각과 외부조각이 발생할 수 있다는 단점이 있습니다.
  - 가변분할은 고정분할과 달리 메모리에 적재되는 프로그램의 크기에 따라 분할의 크기, 개수가 동적으로 변하는 방식입니다. 가변분할은 내부조각이 발생하지 않지만 이미 메모리에 존재하는 프로그램이 종료될 경우 중간에 빈 공간이 발생하게 되며, 이 공간이 새롭게 시작되는 프로그램의 크기보다 작을 경우 외부조각이 발생할 가능성이 있습니다. 이런 가변 분할에서는 물리적 메모리 내의 가용 공간 중 어떤 위치에 올릴것인지 결정하는 문제(동적 메모리 할당 문제)를 고려해야 하는데, 이에 대한 방법으로 최초적합, 최적적합, 최악적합이 있습니다.
- `불연속할당 방식 - 페이징, 세그먼테이션, 페이지드 세그먼테이션`
