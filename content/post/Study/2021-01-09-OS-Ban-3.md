---
title: 운영체제와 정보기술의 원리 정리
date: 2021-01-11
tag: [Study]
---

`참고` 이 글은 반효경 교수님의 "운영체제와 정보기술의 원리"를 바탕으로 공부한 내용을 정리한 것입니다.

<br><br>

## 3장 컴퓨터 시스템의 동작 원리

### 1. 컴퓨터 시스템의 구조

- 컴퓨터 시스템은 컴퓨터 내부장치(CPU, 메모리)와 외부장치(디스크, 키보드, 마우스, 모니터, 네트워크 장치 등)로 구성됩니다.  
- 운영체제는 각종 자원 관리를 위해 항상 메모리에 올라가있어야 하는데 모든 코드가 메모리에 올라가게되면 메모리가 낭비되므로 핵심적인 부분만 메모리에 올리게됩니다. 이를 `커널`이라고 부릅니다.

### 2. CPU 연산과 I/O 연산

- 각 입출력 장치들의 I/O 연산은 `입출력 컨트롤러`가 담당하고, 컴퓨터 내에 수행되는 연산은 메인 CPU가 담당합니다.
- 그리고 각 입출력 장치들의 컨트롤러는 장치로부터 오고나가는 데이터를 임시로 저장하기위해 `로컬 버퍼`라는 작은 메모리를 가지게 됩니다.
- 장치로부터 로컬 버퍼로 데이터를 읽어오는 역할은 컨트롤러가 담당하는데, 이 역할이 끝나게되면 인터럽트를 통해 CPU에게 작업 완료를 알리게됩니다.

### 3. 인터럽트의 일반적 기능

- 운영체제 커널 안에는 각 인터럽트에 대한 처리 루틴이 미리 프로그래밍 되어 있어서 인터럽트가 발생하면 이를 사용합니다.
- 인터럽트에는 `하드웨어 인터럽트`와 `소프트웨어 인터럽트`가 있습니다. 하드웨어 인터럽트는 통상적으로 우리가 일컷는 인터럽트를 말하며, 소프트웨어 인터럽트는 예외상황(Exception)이나 시스템 콜(System call)로 인해 발생하는 인터럽트를 의미합니다. 여기서 예외상황은 0으로 나누는 것, 자신의 메모리 바깥 영역에 침범하는 등의 예외적인 상황을 말합니다.

### 4. 인터럽트 핸들링

- 인터럽트가 발생하면 실행중이던 프로그램의 상태를 PCB에 저장한 뒤, 인터럽트 처리 루틴에 따라 인터럽트를 처리하게 됩니다. 그리고 인터럽트 처리가 끝나게되면 저장해두었던 상태를 프로그램의 PCB로부터 복원해서 인터럽트 당하기 직전의 위치부터 실행을 재개합니다.

### 5. 입출력 구조

- 입출력 방식에는 동기식 입출력과 비동기식 입출력이 존재합니다.
- `동기식 입출력`은 어떤 프로그램이 입출력 요청을 했을 때, 입출력 작업이 완료된 뒤에야 후속 작업을 수행할 수 있는 것을 말합니다. 이때문에 동기식 입출력에서는 CPU가 입출력이 끝날때까지 기다리기 때문에 CPU 자원을 낭비하게 됩니다. 따라서 일반적으로는 프로그램이 입출력을 수행하는 경우 CPU를 다른 프로그램에게 넘겨서 CPU를 계속 사용하도록 하고, 입출력 과정이 완료될 때까지 해당 프로그램을 Block 상태로 만들어서 CPU를 할당하지 않습니다.  
  (참고로, 입출력 과정이 완료되면 위에서 설명했듯이 입출력 컨트롤러가 CPU에게 인터럽트를 보내게되며 Block 상태가 해제됩니다.)
- 이런 동기식 입출력은 입출력에 걸린 프로그램으로부터 CPU를 빼앗아 다른 프로그램에게 넘기기 때문에 연산 과정의 순서가 꼬일 위험이 있습니다. 이러한 문제점, 즉 동기화 문제를 해결하기 위해 장치별로 큐(Queue)를 두고 요청한 순서대로 처리합니다.
- `비동기식 입출력`은 어떤 프로그램이 입출력 요청을 했을 때, 다시 그 프로그램에게 CPU를 부여합니다. 이렇게 함으로써 입출력 결과로 나올 데이터를 사용하지 않는 작업을 먼저 수행합니다.
- 일반적으로는 동기식 입출력을 사용한다고 합니다.

### 6. DMA(Direct Memory Access)

- 원칙적으로 메모리는 CPU만이 접근할 수 있는 장치입니다. 따라서 CPU가 아닌 장치가 메모리에 접근하기 위해서는 CPU에게 부탁하는 방식으로만 가능합니다.
- 하지만 이렇게 하다보니 입출력 장치가 메모리 접근을 원할때마다 CPU에게 부탁을 하게되고 CPU는 자기 할 일을 못하게됩니다.
- 이러한 문제를 해결하기 위해 CPU 이외에 메모리에 접근할 수 있는 장치를 하나 더 두었는데 이것이 바로 `DMA`입니다. DMA는 일종의 컨트롤러로, 로컬버퍼에서 메모리로 읽어오는 작업을 DMA가 CPU 대신 수행해서 CPU가 이로인해 방해받지 않도록 합니다. DMA는 이렇게 로컬버퍼의 데이터를 메모리로 읽어온 뒤 CPU에게 완료되었다는 인터럽트를 발생시키게됩니다.

### 7. 저장장치의 구조

- 컴퓨터 시스템을 구성하는 저장장치는 주기억장치와 보조기억장치로 나뉩니다.
- 보조기억 장치의 용도는 파일을 저장하기 위한 파일 시스템용과 메모리의 연장공간인 스왑 영역이 있습니다.
- 현대의 컴퓨터는 프로그램 수행에 당장 필요한 부분만 메모리에 올려놓고 그렇지 않은 부분을 `스왑 영역`에 내려놓게 됩니다.

### 8. 저장장치의 계층 구조

- 레지스터 - 캐시메모리 - 메인메모리 - 마그네틱디스크 - 광디스크 - 마그네틱테이프

### 9. 하드웨어 보안

- 운영체제는 하드웨어적인 보안을 유지하기 위해서 커널모드와 사용자모드를 나눕니다. CPU 내부에 모드비트(mode bit)라는 걸 두고 0일 때는 커널모드, 1일때는 사용자모드로서 명령을 수행할 수 있게합니다.

### 10. 메모리 보안

- C언어 포인터 등 메모리 주소 참조 연산을 잘못해서 다른 프로그램의 메모리 영역이나 커널 영역을 참조하게 될 수 있습니다. 이는 보안적인 문제인데, 이는 2개의 레지스터를 사용해서 프로그램이 접근하려는 메모리 부분이 합법적인지 체크함으로써 해결할 수 있습니다.
- 2개의 레지스터는 기준 레지스터와 한계 레지스터입니다. `기준 레지스터`에는 프로그램이 접근할 수 있는 가장 작은 주소가, `한계 레지스터`에는 프로그램이 접근할 수 있는 범위를 보관하고 있어서, "기준 레지스터에 있는 주소 ~ 기준 레지스터에 범위(한계 레지스터 값)을 더한 만큼"까지의 범위만을 프로그램이 접근할 수 있게됩니다.

### 11. CPU 보호

- CPU가 하나의 프로그램에 의해 독점되는 것을 막기 위해 OS에서는 타이머(timer)라는 하드웨어를 사용합니다. 타이머는 정해진 시간이 지나면 인터럽트를 발생시켜서 운영체제가 CPU의 제어권을 획득 할 수 있도록 합니다.
- 타이머는 매 클럭 틱(clock tick)마다 1씩 감소하고 0이되는 순간에 폭발합니다.

### 12. 시스템 콜을 이용한 입출력 수행

- 입출력은 특권명령에 해당하므로 사용자 프로그램이 직접 수행할 수 없습니다. 따라서 운영체제에게 시스템 콜을 요청하여 입출력을 수행하게 됩니다.
- 즉, `시스템 콜`은 입출력 명령을 사용하기 위한 인터페이스라고 볼 수 있습니다.

---

## 4장 프로그램의 구조와 실행

### 1. 프로그램의 구조와 인터럽트

- 프로그램이 CPU에서 명령을 수행하려면 해당 명령을 담은 프로그램의 주소 영역이 메모리에 올라가 있어야합니다. 이때 프로그램의 주소 영역은 코드, 데이터, 스택 영역으로 구분됩니다.
- `코드(code) 영역`은 우리가 작성한 코드가 CPU에서 수행할 수 있는 기계어 명령 형태로 저장되는 부분이고,
- `데이터(data) 영역`은 전역 변수 등 프로그램이 사용하는 데이터를 저장하는 부분이며,
- `스택(stack) 영역`은 함수가 호출될 때 호출된 함수의 수행을 마치고 복귀할 주소 및 데이터를 임시로 저장하는 데 사용되는 공간입니다.

### 2. 컴퓨터 시스템의 작동 개요

- `프로그램 카운터(Program Counter: PC)`란, CPU가 수행해야 할 메모리 주소를 담고 있는 레지스터를 의미합니다. CPU는 매번 PC가 가리키는 메모리 위치의 명령을 처리합니다.

### 3. 프로그램의 실행

- 각각의 프로세스는 자신만의 물리적인 메모리 주소 공간을 갖습니다. 그리고 이 주소 공간 안에서 코드 영역, 데이터 영역, 스택 영역을 가지는데, 이처럼 프로그램마다 독자적으로 존재하는 주소공간을 `가상 메모리`라고 합니다.
- 운영체제 커널 역시 코드 영역, 데이터 영역, 스택 영역을 가집니다.
- 커널의 코드 영역은 CPU와 메모리 자원관리 같은 역할을 하는 부분이 주를 이루며,
- 데이터 영역에는 각 프로세스의 상태, CPU 사용 정보, 메모리 사용 정보 등을 유지하기 위한 자료구조인 PCB를 두고 있습니다.
- 커널의 스택 영역에는 현재 수행 중인 프로세스마다 별도의 수택을 두어 관리하는데, 프로세스가 시스템 콜을 호출하였을 때 시스템 콜에서 호출하는 함수들의 주소를 보관하여 호출 이후 다시 복귀하기 위함입니다.

### 4. 사용자 프로그램이 사용하는 함수

- 프로그램이 사용하는 함수는 크게 3가지로, 사용자 정의함수, 라이브러리 함수, 커널 함수가 있습니다.
- 사용자 정의 함수는 개발자가 직접 작성한 함수를, 라이브러리 함수는 다른 개발자가 작성해 놓은 함수를 사용하는 것을 의미하며, 두 가지 모두 해당 프로그램의 코드 영역에서 관리됩니다.
- 하지만 커널 함수의 경우에는 운영체제 커널의 주소 공간에 코드가 정의됩니다.

### 5. 인터럽트

- CPU는 프로그램 카운터가 기리키는 곳에 있는 명령을 수행하는 일밖에 하지 않기 때문에, 현재 수행 중인 프로세스로부터 CPU를 회수하여 다른 프로세스에세 CPU를 할당하기 위해서는 인터럽트 매커니즘이 필요합니다.

### 6. 시스템 콜

- 프로그램이 CPU를 할당 받고 명령을 수행하다가 중간에 CPU를 빼앗기는 경우는 두 가지 경우입니다. 첫번째는 타이머 인터럽트에 의해 빼앗기는 경우이고, 두번째는 시스템 콜로 인해 CPU를 빼앗기는 경우입니다. 시스템 콜을 통한 작업은 시간이 오래걸리므로(예를들면 입출력) 해당 프로세스를 Block 상태로 만들어 놓은 뒤 다른 프로세스에게 CPU를 넘겨주어 CPU가 놀지 않도록 합니다.

### 7. 프로세스의 두 가지 실행 상태

- 프로세스의 실행 상태는 `사용자 모드에서의 실행 상태`와 `커널 모드에서의 실행 상태`로 나뉩니다. 프로세스가 일반적으로 실행중일 때는 사용자 모드에서 실행되지만 시스템 콜을 사용하게되면 커널 모드로 스위칭되어 커널 모드에서의 실행 상태가 됩니다. 이때, CPU는 운영체제에게 빼앗기긴하지만 결국 해당 시스템 콜로 인한 작업 역시 해당 프로세스를 위한 작업이므로 실행 상태로 간주합니다.
