---
title: 2020-08-12 TIL
date: 2020-08-12
tag: [TIL]
---

## Facts

- 아침에 [웹을 지탱하는 기술 스터디 1](../../../Study/2020-02-25-web-supporting-tech-1.md)를 복습하였습니다.
- 부스트 캠프 챌린지에 참여하였습니다.

## Feelings

- 오늘 미션은 정말 어려웠습니다. 하지만 EventEmitter를 이용한 구현은 처음 해보았는데 좋은 경험이었던 것 같습니다.

## Findings

- setImmediate
- EventEmitter
- 모듈/객체를 어떻게 나누고, 어떻게 모듈간의 협력관계를 맺는게 좋은지 자기만의 기준을 정리한다.
- 비동기 방식으로 구현할 때 어려운 점은 무엇이고, 디버깅을 쉽게 도와주는 다양한 방법을 찾아서 비교한다.
- 스레드를 생성하는 것과 여러 비동기 방식을 비교해보고, 어떤 제약사항이 있는지 비교한다.

- **JavaScript 비동기 처리 방식**
  - `callback`

      ```javascript
      const main = () => {
          setTimeout(() => {
              console.log(1);
              setTimeout(() => {
                  console.log(2);
                  setTimeout(() => {
                      console.log(3);
                      setTimeout(() => {
                          console.log(4);
                      }, 1000);
                  }, 1000);
              }, 1000);
          }, 1000);
      };
      ```
  
  - `Promise`

      ```javascript
      const main = () => {
          const myPromise = (value) => {
              return new Promise((resolve, reject) => {
                  setTimeout(() => {
                      console.log(value)
                      resolve(value + 1);
                  }, 1000);
              });
          };

          myPromise(1)
            .then(v => myPromise(v))
            .then(v => myPromise(v))
            .then(v => myPromise(v));
      };
      ```

  - `async/await`

      ```javascript
      const main = async () => {
          const print = (value) => {
              return new Promise((resolve, reject) => {
                  setTimeout(() => {
                      console.log(value)
                      resolve(value + 1);
                  }, 1000);
              });
          }

          await print(1);
          await print(2);
          await print(3);
          await print(4);
      };
      ```

- **디스트럭쳐링**
  - 까먹고 있었는데 요런 좋은 방법이 존재했었습니다.

    ```javascript
    const [head, ...body] = ['머리', '가슴', '배', '다리'];

    console.log(head); // '머리'
    console.log(body); // ['가슴', '배', '다리']
    ```

- **bind와 화살표 함수**
  - 일반 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정되는 것이 아니고, 함수를 호출할 때 함수가 어떻게 호출되었는지에 따라 this에 바인딩할 객체가 동적으로 결정됩니다. 하지만 화살표 함수는 함수를 선언할 때 this에 바인딩할 객체가 정적으로 결정됩니다. 화살표 함수의 this는 언제나 상위 스코프의 this를 가리킵니다.

    ```javascript
    class Example {
        name = 'woomin';

        printName() {
            console.log(this.name);
        }

        useBinding() {
            setTimeout(this.printName.bind(this), 1000);
        }

        useArrowFunction() {
            setTimeout(() => this.printName(), 1000);
        }
    }
    ```

## Future Action Plans

- 공부할 게 쌓여만 가는데 해결할 시간은 부족해지네요 ㅜㅜ

## Feedback
